package com.location.algorithm.design.prototype

/**
 * 原型模式(创建型模式)
 * 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
 * 优点：
 * 1.性能优良
 * 2.逃避构造函数的约束
 * 缺点：
 * 1.需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造的时候，需要修改代码，违背了开闭原则
 * 2.当实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦
 * 3.深克隆会带来性能问题
 * 4.原型模式简化了创建过程，但是却增加了系统的复杂度，使用原型模式的系统，必须要有一个专门地负责克隆新对象的工厂，而且在客户端代码中，增加了与克隆相关的代码
 * 5.原型模式的重要性不是很大
 * 6.原型模式的克隆分为浅克隆和深克隆，浅克隆只会克隆对象本身和对象中的值类型的成员变量，而引用类型的成员对象并不会被克隆，深克隆会将引用类型的成员对象也克隆
 * 7.原型模式的实现一般都需要将克隆过程写在一个克隆的工厂中，这个工厂类通常是单例的，因为在整个系统中，克隆的工厂类只需要一个[com.location.algorithm.design.prototype.Manager]
 */
fun main() {
    val manager = Manager()
    manager.register("man", Man())
    manager.register("woman", WoMan())
    val product = manager.create("man")
    product.use("dsa")
}